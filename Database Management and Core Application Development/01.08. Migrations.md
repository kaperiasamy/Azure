# What are migrations
Convert the following content into clean, interview-ready bullet points for easy reference. Please avoid using Unicode characters in the response:
So now we're going to take a look at migrations. This is a word that I have mentioned before and we even saw a folder in our project called migration. So let's take a few minutes to understand what they are. So migrations are typically used in code first, database development and the challenges that would really lead to us wanting to use migrations would include the fact that database changes are difficult to track if I change a column. If I created a new table, like who is really checking to see that I did it properly, who is really aware of the fact that I have done it and what audit trail is there? So database engines typically don't contain that kind of auditing system in Italy. So migrations help us to see what was done. So it acts sort of like a version control for our database. 
So similar to how github helps us to see who changed what and at what point in our code, we can use migrations to see that this is what happened at this particular time relative to the database's design, they even serve as a manual backup for or rather an automated backup mechanism for databases. Because if you wanted to put, you know, take down a database today and then spin it back up or you want to spin up multiple versions of the same database using migrations. That's a very easy process. So database migrations use EF core tools to add migrations describing the updates that need to be made to the database. So we discussed that before um the EF core tools package. Now this is needed more for the package manage manager, console commands, which are really partial commands. And that's really in visual studio, they're not necessarily needed in visual studio code because the .NET CLI has built in commands for entity framework which could also be used in visual studio once you have access to a CLI. 
Now, if core compares the current database with a snapshot of the old database and generates a migration file aligning the changes to be made. So any column change, any property, any new entity that you create or remove or modify, it's comparing what obtains with what is not there. And then it generates a file outlining the different changes that need to be made to the database model. And finally, migrations can be applied to a database and each one is tracked in a history table in the database. So every time you have new migrations and then you actually want to update the database, there's a second step where it says here's the last migration that I carried out and here is the new migration. Ok. These are all the changes needed to get up to date. 
So let's jump over to the code and explore this. 

# Adding a Migration
Convert the following content into clean, interview-ready bullet points for easy reference. Please avoid using Unicode characters in the response:
All right. So we're back in code and uh and what we're going to be doing is looking at migration. So let's jump over to our data folder and expand the migrations folder. And I will see that we have a migration here waiting for us. And the name of the migration is create identity schema. So we didn't create that. I didn't create that. 
And you would have this as well if you chose the identity inclusion, the individual accounts inclusion when you are creating the project. Now, if I take a look in this file, at first glance, it looks very confusing and very, very complicated, but it really isn't as a C# developer. If you just sit down and calmly read through the file, you'll see exactly what it is saying. Now here they're creating a partial class called create identity schema, which is inheriting from some based class called migration. Generally speaking, you don't need to touch this file. It's already doing everything for you because it's did its assessments already based on your coding activity and it will generate this for you. But it is a good uh It is good to understand what the file is saying and what it's about now here we have a method called up and where there is up, there's also down. 
So we have up and down two methods. Let's explore up. First up, describes what needs to happen to the database. What changes need to be carried out. The first change is that we're going to create a table. The name is P net roles and the columns of this table are ID name, normalized name and concurrency to the right hand side of it, you'll see what a column, data type is and if it is knowledgeable or not, and it's maxent, right? So it's if you know how to create a table in SQL, you shouldn't have a problem reading through this file, right? 
Because really and truly, it's not SQL but it is outlining everything that we would have outlined if we were to write SQL statements to do this. So because we chose identity and because we have that identity db context, we got this automatic migration which is creating some default P net tables for us for user management and interactivity. So we have a table here for rules. We have a table here for the users. We have a table for rules claims and I'm not going to go through every single table. There are several tables that you're just going to get by default just because you selected the individual accounts. We will explore these in more detail later on now dawn has to do with what changes need to happen if I change my mind about the changes that I just applied. 
So the changes I just applied would have been done in the create all these tables. But for every table, for every index, for every relationship and whatever it is I'm creating, I would want to undo it. So the tone has opposite commands to the up, right? So where it says create table in the up, we have drop table in the dawn and that's really all there is to it. Youre up, you, you drop in dawn, you undo you doing up, you undo in down. It's really that simple. So we'll be creating more of these as we go along because every time we have to create new database tables to support the new features that we're building out in this application, we have to create a migration for now. 
However, we have a default one and when we come back, we're going to look at how we can execute this default migration and get a database on the other end of this operation. 

# Create Database from Migration
Convert the following content into clean, interview-ready bullet points for easy reference. Please avoid using Unicode characters in the response:
So now we want to create the database. So we have no database. All we have is a file called a migration with some instructions for a table. And the cool thing about ef core migrations and all of those put together is that if there's no database and you run the command that we're about to run, it will actually create the database and carry out all of the migrations for you. In this case, we only have one migration. So only one operation will be completed. However, if we had 10, then it would go through and apply all 10 migrations. 
So the database that gets created is the database based on what we're expecting at that point in a project. So enough of my monologue, let's jump into it. So in visual studio, I'm going to open a package manager console and we can simply write the command update database. Now, when I to update that database, it's going to build, make sure that there are no compile errors, then it's going to check the appsettings, it's going to check the DB context, make sure that everything is good there and then it's going to check for the migrations, it's going to see that there is no database by that name and then it's going to go ahead and apply the migrations to the no newly formed database. So it may take a few seconds on the first run. So we give it a little time. So when it completes what you will see inside of the console and I'll just increase it. 
So we get a little more real estate is a bunch of SQL statements. So basically the first statement is create the EF core migrations table. Well, the databases didn't exist. So it says create database actually, firstly, and then it creates the migrations table and then it goes through and then it looks at the migrations, what are the ones applied? Versus what are the ones that need to be applied? In this case, it's only one. So it hasn't been applied. 
So it says applying the migration which then generates, generates the SQL statements to match with the commands that we just reviewed in the file. Ultimately, when you see done, that's a good sign. If it had errors, then you would see some red and yellow writings appear in this console. And they would of course tell you where the arrow might be going forward, we might encounter errors and when we do, we'll be sure to work through them. But for now, this should have run successfully for you on the first time. Now, if you're not on windows and you have to rely on the .NET C and visual studio code or some other ID, what you'll need to do in the terminal. 
Once of course you are inside the folder with the project. Firstly, you need to install the .NET tool for .NET EF so you can run this command .NET tool, install global. So it's available for every user on your PC and then .NET dash EF once that is done, you also need to add a package .NET ad package, Microsoft dot entityframework core dot design. 
So we went through this net a package previously, you have to have this package present in your project. So go ahead and add it if you're starting from scratch and you have to add the migration manually, you can do. So by saying .NET EF migrations add and then you give the migration a name. So usually the name should be indicative of whatever changes you're making for the first one, you could always say like initial migration or init something like that. And then once you have the migration added successfully, what you want to do is .NET EF database update. 
And this would be the equivalent of what we just ran where we said update database. So whether you're using windows or not, these net cli commands will work once you have the net EF tools installed. So finally let us go and look at the database. So from visual studio, if you are using the local DB server given to us by visual studio, you can access the database in visual studio by going to view and you're going to look for the SQL object explorer. There it is. And from here you can access that builtin instant so you can expand a secure server and then you'll see like you have three instances. But one of them is the local DBMS SQ, localdb. 
You can expand that look at the databases you can see here that I have several databases. But the one that I'm looking for is one labeled leave management system db. And if I zone in here, I will see it there. It is, I hovered over it several times. So leave management system db and I can expand and I will see the tables. So if you want to verify that these tables were indeed created by the SPO statements, you can do that, right? So here it says create table sp net user tokens. 
Well, here's that SP net user tokens table. So everything that was in the migration has now been applied to this new database. Now, I can also access this database, like I said, using a regular or the server rather using another database management tools. In this case, I'm going to use the Azure Data studio which is a cross platform and open source um the database management tool that you can use whether you're on Windows or other platform. So I'm going to use this one because everybody has access to it. And from here, I can go to this new connection and type in the server, which is localdb with one slash then MSSQ localdb, I'll leave it as Windows authentication and then go ahead and connect. And then from here I can expand databases and then I will see my leave management db. 
Here there it is. So if you don't want to do it inside visual studio, you can always use this third this or another third party tool. And similarly, if you did not use the local db as given to us by visual studio, whether you used um one from another, you know, another instant somewhere like your MS SQ express or your localhost, which would be the full installation or you're using a Docker container, whichever it is, you wouldn't use the object explorer in visual studio. You would use more like a server explorer which actually allows you to connect to a server. But then that interface is kind of tiny and I don't really like using it in visual studio. So I would just use this third party tool just the same, just connect to the server and then you are able to interact with your database. 


I am having my ASP.NET Core Web application opened in Visual Studio Code and I don't have Visual Studio installed. Now I want to have Entity Framewrok Core in this project. What are the commands I have to run to have Entity Framework Core in the project and the database is created with Code First Approach. Assume that I am going to use SQL Server. I am using IdentityDbContext. The database name is `LeaveManagementSystem`. I will add the tables after that. 
