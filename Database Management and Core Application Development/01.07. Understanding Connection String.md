Convert the following content into clean, interview-ready bullet points for easy reference. Please avoid using Unicode characters in the response:
All right. So what is the connection string in basically any technological Stack in development, you're going to see the term connection string. And it's really just a set of instructions on how to find the database. So it's generally defined at least in .NET core in an appsettings dot JSON file. Even though in production, you may want to consider making it what we call a secret. So it's not easy to access in source code. 
So the connection string generally defines the location of the database. It defines the name of the database and credentials that need to be used to access the database. So it may look different for different database engines. For instance, for an SQL server connection string, we have server equals and then some locations. So it can be on a different server. It could be an IP address, it could be my local server. So based on where that server is and the instance that you're connecting to, we have the database with the name and its value, we also have user id, which would be the user name and the password, which is the password. 
And because all of that has to be in plain text. It's fine to put that in the appsettings JSON during development. But in a production system, like I said, you probably wouldn't want to publicly expose the user id and password like that. So I'm just giving you a nugget for later when we're doing deployments. And then in contrast, a SQL light, which is another type of database engine that is supported by EF core, the connection string may look something simple like this because it's really just a file. So the SQL light actually is just a file that sits in a folder somewhere. So you have the path to the file and then if it is a shared database or not. 
So back in visual studio, we head over to our appsettings dot JSON file. And in here, we'll see a whole block dedicated to connection strings. So this connection strings, section points to the default connection string. So you can actually change this name, that's the stability name. But of course, if you change it here, you'll have to change it in other places. And I'm going to show you where else you need to change it. So this is the name and or this is the key and this is the value. 
So anytime you want to know what a connection string is for this database, you just call that key. So if you have multiple databases in your application, you simply need to comma separate them in this whole connection strings, section, each one should have a unique key. Now, the connection string once again points to where the database is. So the first thing here is the server. Now, visual studio has a built in server and it's called localdb slash MSSQL, localdb. Now it's really one slash but because of um piing you have to use and a second slash as an escape. All right. 
So it's server equals and then this is the name of the server. So if you have a database management system like Azure data Studio or skill management studio, you can actually type in all of this just with one slash though. And you can connect to the database server if you're using a different database server. Like for instance, I also have localhost on my machine. I have a database server phone at localhost, I also have SQL Express which would be localhost slash SQL, sorry SQL express. I also have SQL EXPRESS 01. So this would be an example of server name slash instance. 
All right. So I'm just showing you that there are different ways for this course though I'm going to use the default built in database engine for S for Visual Studio. If you are not on a Windows machine and you are not able to set up SQL server at all. Because even if you're using VS code on Windows, you can still use a developer SQL server or an SQL Express edition. But if you're using neither. Um And you're not using Windows, I would suggest that you use site so you can check on the references for EF core and sqlite. But I'm focusing on SQL server for this particular course and lesson. 
So that is the location of our database. Next, we have the name of the database. So we got a randomly generated database name and I'm sure it's going to be unique for every single project that you generate. But at this point, we can change that name. So I don't want it to be a Pnet dash. I want to just say leave management system. Uh let's say db. 
All right, I think that is nice and simple. So whatever you want the database to be called, you can change that connection string accordingly. Now, the rest of it will be trusted. Connection is true. We can leave that multiple active result sets equal true. And one more recent addition that you wouldn't see is encrypt. So I suggest that you just put on a semicolon and write encrypt equals falls onto the end of the connection string to help to avoid any issues. 
Um Sorry point of information. If you are not using windows and you want to use SQL server, then I suggest that you use a Docker container to install that. So you can check out the reference for that in this course. All right. So you can install, you can set up SQL server with a Docker container and then you just change that location to point to the SQL server running in the container. So that is really all there is to connection strings, right? It's just a string that tells you where to find what and how to connect to it. In this case, because I'm using the built in database engine, it will use my windows login to connect. But later on when we're doing deployments and the server is not my local machine, then I need to have the user id and password as a part of the string. 
Now this string is being used in the program dot CS. So here in the program dot CS, you see where it says connection string and then it uses this builder to get the configuration. And this configuration basically is a materialized version of the appsettings that JSON information, right? So this is how in C# we can access or in the program that we can access different parts of our configuration file here. So it's saying get connection string, this method is automatically going to look in this whole section. And then we're saying get this key. So earlier I mentioned, if we change the key here, then we're going to have to change it elsewhere and that elsewhere is here. 
So it says at application startup, go ahead and get the connection string and throw an Exception if there is no connection string found. All right. So this part is actually optional, we can live with all that. But I'm sure you can appreciate why it would do that. If I don't have a connection stream, then don't start the application because I need the database. Then after it gets a connection string, it's going to go to this line where it says add the DB context. So we spoke about the database context in the last lesson and the database context represents that connection or that representation in the date of the database in the application. 
So here we're saying, go ahead and add this specialized class as the database context and we're using SQL server and here's the connection string. All right. So if you are using a different adapter, then you would see something like use SQL light, right? Or use MySQL for instance. So those are, that's basically how it would look if you're using a different database engine. But in code and in practicality, it will be the same concept, just variations based on the engine. And that's really all there is the connection strings. 
Now, when we come back, we're going to take a look at migrations and what they are. 